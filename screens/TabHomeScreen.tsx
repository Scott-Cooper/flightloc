// https://flightloc.pythonanywhere.com/dump_it_all_or_else
// https://flightloc.pythonanywhere.com/clear_it_all_or_else
// https://flightloc.pythonanywhere.com/loc?key=fake135&user=Boot%20Barn&lat=37.671257&long=-97.417910&alt=1270&heading=125&speed=24.86&accuracy=17.2&alt_accuracy=35&max_distance=60&max_lag=20000&min_speed=-1
// https://flightloc.pythonanywhere.com/loc?key=fake205&user=Vortac&lat=37.745261&long=-97.583838&alt=1278&heading=182&speed=8.23&accuracy=19&alt_accuracy=79&max_distance=60&max_lag=20000&min_speed=-1
// https://flightloc.pythonanywhere.com/loc?key=fake923&user=Field&lat=37.668453&long=-97.701083&alt=1302&heading=45&speed=27.49&accuracy=36&alt_accuracy=143&max_distance=60&max_lag=20000&min_speed=-1
// https://flightloc.pythonanywhere.com/loc?key=fake117&user=Norwich&lat=37.457929&long=-97.835638&alt=1200&heading=0&speed=24.3&accuracy=16.2&alt_accuracy=13&max_distance=20&max_lag=20000&min_speed=5

// https://www.typescriptlang.org/play?ssl=45&ssc=31&pln=45&pc=1#code/PTAEAkHsHdQE0qAkqAzpATgF1FgFgJappYYCuAxlmRgKagBGAnvLRbQHZwEcDm8RAPwAoEKACCAG3S4mAB1qoKGAnJx4AhlkWgAtiwqQ4tAHRnRYAMqRJZLAUgdBoUHixY5qAFwgGkBsyacABeJoa6wAySkLzAWPKKyqpYALQckCk8xgAeKagEvBxaNLQp0AT4KXIaGBq6tNoYKZAAZinxCnmkPLzCwgBuNaDZoAC8oADewi4uAEQEcADMAOzLs16T0zPbswy0NT3roIuLAIwANFvbc9yoRwBsJgAsl9czs2SotBhHswDSNU4syuoAAvq93gtTstFkcpm85nsDnwjgAmACsqIhb1mtzRJmW2OuHy+Pw2-1o-R4wO24JB8zgqIADOi4SCdkiVCiNtCABxEnZ4jYAThM6IF70+31+ABVatSiaDhEqBkNiOMAOQAHQ4GuELUwoAAFJIGqAANa0Fg8YYASk22zExAA1ONsgBtS1MAC67o1UowGu9oGdoFmYZDw09Vt9GtuQcj4d0BFNqHOjH2XP44dDHq9sc5PQTodmOppMydIbd0ZYGmIXtasgUjeysYDxYjOajXtAdYtVsbHVoLdj8eDJb0KcU6cLfAjuZrvfrA5aTeHq9bftnvA7pY4wJBgwwuB74x7fYbq6HLZBLurWHzfvb487kY9D5jfrHicnqZnmZ6ecow-H0twAvhdzLZVhEMDh0FNExol4I1UFtPpYPg0wkKND0GWhWFfVxIhZm9NCMJsLCYhw908JhEiTFuMjHEwxCqOyEwoRhGi8VImDmIo1jkPYzjFgYog0KPC0xjDETgUkuBpKIu4+LggTsLzb0xNQlSWPUz1CJ4pjVIQvTzV9OBeJ0tS2M9Jd+yYQcEhHLTbQAbj6SSQOk807MvNcb3IkybJAzTGPcvoIrEcQAAUUAAUWyOo5FTCxXHcTwfGAFpJAKNxogoEw5CYfBHA0DgmGgPBvlMcJgHywQvVGFoNEtVZFgAMgDUY-kpHh2skLRRhWAlTl5dF+scXhRhSYVljFUamXajRJCwUZTnuXlHiZe50XGqqNG4PhRnROblnRM52tQBRaDgUZUVE3lhV5J4looCgaA0CgmDWubFuWrAAH1Pve2ovqGxbdA0bIAduLAyvYY6IahgGBqm5kmQx9rkw4AGrtoG7ptOVK3A8bwQGy3KsHywrirwUrysq6qwkgCJ6sa5rLRWZZOtJbrAQ4frBuG3lTkWVEJqOma5sxE6lpWtamRhAlMRe-bDqm05FZG9FhUu67boxExUVRJ7XpBz7vuhEw-pWoG3o+sHFiR6HYfh2hEax5HUbujHMex3H9cJ4n0rJrKct4PLIAKoqSqKBmqroZnWajhqrSalraFF8auoAIUgSAsAAUmZHOagFgbVuG+5llODFueiSXZueaFhU1uXVtr5ZFrVno1oxPX8YNp4TE2s2Hctubxf+u3zcd8bIZdog4Y4BH7mdlGNDR32IZ4APB6DsQSYy8nw8j6PafpiqE5qlm6pT9mM+ZbPeYANUwOGKEFyvTqeTF7lOCWU0pZil5IsUBvJ2592WBAnuR1RrizxgTXkRsOrA3HmtXW080Gg2+ssXWC8YZLzdqMNentobe3Rn7XeiDbopCJofEOmUKYRyplHGmscypXyZrVNmacOa0GFPdHm3xRgADECC0EkHAL+Q05r3A2r-DqDcgFNy7prUBkDRZMnFrAqav8B4E1RHNJ4mD7Y4KGvcduM90GnCeB1AhrsV7u1IQQih28sbUMDnQ4OpMmGn1YefDh8duG314d9fhpxoTCIwKMAAcpgcoFA8AyOGr-PBJtAHTSbqA9E9wwGaPRu1XRoxFo0LusPVBZiLZrUeFPW22DqmizIYQ1Ay8EbMmaW432HicZlPRD44+YdKbUxjnTOOXDE61TgGQXQcgAYVCBpISQANMAA0kV8AZodmFn3YWMzhjNJm3woKaGo8zAbLWWas9ZtAgA


import { Text, View } from '../components/Themed'
import { StyleSheet, Image } from 'react-native'
import { ImageBackground } from 'react-native'
import * as Location from 'expo-location'
import React, { useState, useEffect } from 'react'
import { activateKeepAwake, deactivateKeepAwake } from 'expo-keep-awake'
import state from '../util/state'
import { convert_angle_to_spoken_digits, convert_bearing_to_spoken_clock } from '../util/misc'
import { getVolume, setVolume, speakAnything } from '../util/speech'
import { VolumeManager } from 'react-native-volume-manager'
var pkg = require('../app.json')


      
// Convert from dict of dict, to sorted array of dict
function orderByDistance( input: string ) {
  let key = "dis"
  let r = []
  let contacts = Object.keys( input ).map( key => ({ key, value: input[key] }) ).sort( (a, b) => a.value[key] - b.value[key] )
  for (var contact of contacts) {
    contact["value"]["key"] = contact["key"] 
    r.push (contact["value"])
  }
  return r
}


export default function TabHomeScreen() {
  const [location, setLocation] = useState(null)
  const [errorMsg, setErrorMsg] = useState(null)
  let logoimg = require('../assets/images/flightloc.webp')


  // useEffect executes when the screen is loaded, only happens once
  // Gets re-run during refresh, so it will get doubled up in debug mode
  useEffect(() => {
    (async () => {
      let { status } = await  Location.requestForegroundPermissionsAsync()
      if (status !== 'granted') {
        console.log('permission to access location was denied')
        return
      } else {
        console.log('access to foreground location granted')
      }

      console.log('activated keep awake')
      activateKeepAwake() 

      console.log('added volume listener')
      const volumeListener = VolumeManager.addVolumeListener((result) => {
        check_vol_buttons(result.volume)
        // returns the current volume as a float (0-1)
        // on android, the result object will also have the keys
        // music, system, ring, alarm, notification
      })

      console.log('set gpsUpdateTime to', state.settings.gpsUpdateTime, 'seconds')
      const getLoc = setInterval(async () => {
        get_gps()
      }, state.settings.gpsUpdateTime * 1000)

    })()

  }, [])


  const check_vol_buttons = (vol: number) => {
  // const check_vol_buttons = async (vol: number) => {
    // console.log("check_vol_button " + vol + '-------------------------------------------------------------------------')
    speakAnything('location', state.next_thing_to_say)
    setVolume()
  }


  const get_gps = async () => {
    console.log('---------------------------------------------')
    // console.log('get_gps running   ', Date.now())

    let location = await Location.watchPositionAsync(
      {
        // accuracy:Location.Accuracy.High,
        accuracy:Location.Accuracy.BestForNavigation,
        timeInterval: 1000,
        distanceInterval: 20,
      }, (location_update) => {
        setLocation(location_update)    
        state.coords.latitude = location_update["coords"]["latitude"]
        state.coords.longitude = location_update["coords"]["longitude"]
        state.coords.altitude = location_update["coords"]["altitude"] * 3.28084
        state.coords.speed = location_update["coords"]["speed"] * 2.2369
        state.coords.heading = location_update["coords"]["heading"]
        state.coords.accuracy = location_update["coords"]["accuracy"] * 3.28084
        state.coords.altitudeAccuracy = location_update["coords"]["altitudeAccuracy"] * 3.28084
        state.coords.timestamp = location_update["timestamp"]
        // console.log('update location:', location_update.coords)
        // console.log('get_gps time      ', location_update.timestamp)
        fetch_api()
      }
    )

    // Save off current volume level.
    getVolume()

    // console.log('get_gps complete   ' + Date.now())
  }


  const fetch_api = async () => {
    
    if (state.coords.timestamp == state.coords.lasttimestamp) {
      // Gets here when flightloc goes to the background for a while, then goes foreground.
      // If this happens there will be a shit ton of queued requests that are all the same, so
      // we simply skip them because they are identical.
      console.log('fetch_api complete with duplicate')
      return
    }

    let stime = Date.now()
    state.coords.lasttimestamp = state.coords.timestamp
    // console.log('fetch_api running  ' + Date.now())

    // try {
      let url = 'https://flightloc.pythonanywhere.com/loc?'
      url += 'key=' + state.settings.keycode
      url += '&user=' + state.settings.user
      url += '&lat=' + state.coords.latitude
      url += '&long=' + state.coords.longitude
      url += '&alt=' + state.coords.altitude
      url += '&heading=' + state.coords.heading
      url += '&speed=' + state.coords.speed
      url += '&accuracy=' + state.coords.accuracy
      url += '&alt_accuracy=' + state.coords.altitudeAccuracy
      url += '&max_distance=' + state.settings.maxDistance
      url += '&max_lag=' + state.settings.maxLag * 1000
      url += '&min_speed=' + state.settings.minSpeed

      // console.log('fetch_api url', url)
      const response = await fetch(url)
      // console.log('fetch_api status  ', response.status)
      // console.log('fetch_api headers', response.headers)
      // console.log('fetch_api ok', response.ok)

      const apidata = await response.json()
      state.apidata = orderByDistance( apidata )
      // console.log('fetch_api:', state.apidata)
    // } catch (e) {
    //   console.log('fetch_api error:', e)
    // }
    let etime = (Date.now() - stime).toString()
    console.log('fetch_api complete ' + Date.now() + '   ' + response.status + '   ' + etime + 'ms')
  }



  let text = 'Waiting..'
  let text_lat = ''
  let text_long = ''
  let text_alt = ''
  let text_speed = ''
  let text_heading = ''
  let text_accuracy = ''
  let text_altitudeAccuracy = ''
  let text_time = ''
  let text_apidata = ''
  let text_pretty_apidata = ''
  let text_spoken_apidata = ''
  
  if (errorMsg) {
    text = errorMsg
  } else if (location) {
    // console.log('Received new location xxx', location)
    text = JSON.stringify(location)
    text_lat = JSON.stringify(location["coords"]["latitude"])
    text_long = JSON.stringify(location["coords"]["longitude"])
    text_alt = JSON.stringify(location["coords"]["altitude"] * 3.28084)
    text_speed = JSON.stringify(location["coords"]["speed"] * 2.2369)
    text_heading = JSON.stringify(location["coords"]["heading"])
    text_accuracy = JSON.stringify(location["coords"]["accuracy"] * 3.28084)
    text_altitudeAccuracy = JSON.stringify(location["coords"]["altitudeAccuracy"] * 3.28084)
    text_time = JSON.stringify(location["timestamp"])
    text_apidata = JSON.stringify(state.apidata)

    const contacts = state.apidata
    for (let i = 0; i < contacts.length; i++) {
      let contact = contacts[i]
      // console.log("contact", contact)
      text_pretty_apidata += contact['user'] + " " + contact['dis'].toFixed(1) + " miles\n    bearing " + contact['bearing'].toFixed(0) + ",    course " + contact['heading'].toFixed(0) + "\n    at " + contact['speed'].toFixed(0) + " mph\n"

      if (i < state.settings.maxContacts) {
        text_spoken_apidata += contact['user'] + ' ' + contact['dis'].toFixed(1) + ' miles'
        if (state.settings.isIncludeBearing) {
          if (state.settings.isRelativeClock) {
            text_spoken_apidata += ", at " + convert_bearing_to_spoken_clock(contact['bearing'])
          } else {
            text_spoken_apidata += ", bearing " + convert_angle_to_spoken_digits(contact['bearing'])
          }
        }
        if (state.settings.isIncludeCourse) {
          text_spoken_apidata += ", course " + convert_angle_to_spoken_digits(contact['heading'])
        }
        if (state.settings.isIncludeAltitude) {
          let ralt = contact['alt'] - (location["coords"]["altitude"] * 3.28084) 
          let salt = ' level'
          if (ralt < -200) { salt = ' low' }
          if (ralt > 200) { salt = ' high' }
          text_spoken_apidata += salt
        }
        text_spoken_apidata += ".\n"
      }
    }

    if(text_spoken_apidata == '') { text_spoken_apidata = 'No contacts' }

    // speakAnything('location', text_spoken_apidata)
    state.next_thing_to_say = text_spoken_apidata
    console.log("\n" + text_pretty_apidata)
    // console.log(state)
  }

  return (
    <View style={styles.container}>

      <ImageBackground style={styles.image} source={logoimg}>
        <Text style={styles.name}>{pkg.expo.name}</Text>
        <Text style={styles.version}>Version {pkg.expo.version}</Text>

        <Text></Text>
        <Text></Text>
        <Text></Text>
        <Text></Text>
        <Text></Text>
        <Text></Text>

        {/* <View style={styles.separator} lightColor="#eee" darkColor="rgba(255,255,255,0.1)" /> */}

        {/* <Text style={styles.gps}>latitude: {text_lat}</Text>
        <Text style={styles.gps}>longitude: {text_long}</Text>
        <Text style={styles.gps}>altitude: {parseFloat(text_alt).toFixed(1)} feet</Text>
        <Text style={styles.gps}>altitudeAccuracy: {parseFloat(text_altitudeAccuracy).toFixed(1)} feet</Text>
        <Text style={styles.gps}>accuracy: {parseFloat(text_accuracy).toFixed(1)} feet</Text>
        <Text style={styles.gps}>speed: {parseFloat(text_speed).toFixed(2)} mph</Text>
        <Text style={styles.gps}>course: {parseFloat(text_heading).toFixed(0)}</Text>
        <Text style={styles.gps}>time: {text_time} milliseconds</Text>
        <View style={styles.separator} lightColor="#eee" darkColor="rgba(255,255,255,0.1)" />
        <View style={styles.separator} /> */}

        {/* <View style={styles.separator} />
        <View style={styles.separator} lightColor="#eee" darkColor="rgba(255,255,255,0.1)" /> */}

        <Text style={styles.gps}>{text_pretty_apidata}</Text>
        {/* <View style={styles.separator}/>
        <Text style={styles.gps}>{text_spoken_apidata}</Text> */}

        {/* <View style={styles.separator} lightColor="#eee" darkColor="rgba(255,255,255,0.1)" />
        <Text style={styles.gps}>api_data: {text_apidata}</Text> */}

      </ImageBackground>

    </View>
  )
}


const styles = StyleSheet.create({
  container: {
    // flex: 1,
    padding: 10,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  gps: {
    fontSize: 13,
    fontFamily: 'space-mono',
    fontWeight: 'bold',
    color: 'black',
    padding: 10,
  },
  separator: {
    marginVertical: 3,
    height: 2,
    width: '100%',
  },
  name: {
    position: 'absolute',
    padding: 20,
    textAlign: 'right',
    bottom: "3%",
    right: "6%",
    color: 'black',
    fontSize: 45,
    fontWeight: 'bold',
  },
  version: {
    position: 'absolute',
    padding: 20,
    textAlign: 'right',
    bottom: "1%",
    right: "6%",
    color: 'black',
    fontSize: 15,
    // backgroundColor: 'red',
    // opacity: 0.2,
    // fontWeight: 'bold',
  },
  image: {
    width: "106%",
    height: "100%",
    // padding: 10,
    // align: 'left',
    // resizeMode: "cover",
    // overflow : "hidden"
  }

})

